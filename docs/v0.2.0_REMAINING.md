# Ziron v0.2.0 - Verbleibende Features & Implementierungsplan

## Übersicht

Dieses Dokument listet alle noch nicht implementierten Features aus der v0.2.0 Roadmap auf und priorisiert sie für die weitere Implementierung.

---

## Priorität 1: Kern-Funktionalität (Höchste Priorität)

### 1. Script-Argumente (`$1`, `$2`, etc.)
**Status**: Nicht implementiert  
**Dateien**: `ziron-shell/src/shell.rs`, `ziron-shell/src/parser.rs`

**Implementierung**:
- Script-Argumente in `ZironShell` speichern
- `$1`, `$2`, `$3`, etc. in Variable-Expansion unterstützen
- `$#` für Anzahl der Argumente
- `$@` für alle Argumente
- `$*` für alle Argumente als String

**Schritte**:
1. `script_args: Vec<String>` zu `ZironShell` hinzufügen
2. `execute_script()` erweitern, um Argumente zu parsen und zu speichern
3. Variable-Expansion in `parser.rs` erweitern für `$1`, `$2`, etc.
4. `$#`, `$@`, `$*` unterstützen

---

### 2. Erweiterte Arithmetic-Expansion
**Status**: Teilweise implementiert (nur +, -, *, /, %)  
**Dateien**: `ziron-shell/src/parser.rs` (Funktion `evaluate_arithmetic`)

**Fehlende Features**:
- Bitwise operations (`&`, `|`, `^`, `~`, `<<`, `>>`)
- Comparison operators (`==`, `!=`, `<`, `>`, `<=`, `>=`)
- Logical operators (`&&`, `||`, `!`)

**Schritte**:
1. `evaluate_arithmetic()` erweitern für Bitwise-Operationen
2. Comparison-Operatoren hinzufügen (return 0/1)
3. Operator-Präzedenz implementieren
4. Tests schreiben

---

### 3. Erweiterte Brace-Expansion
**Status**: Teilweise implementiert (nur einfache und Range-Expansion)  
**Dateien**: `ziron-shell/src/parser.rs` (Funktion `expand_brace`)

**Fehlende Features**:
- Nested brace expansion: `{a,{b,c}}` → `a b c`
- Prefix/suffix expansion: `prefix{a,b}suffix` → `prefixasuffix prefixbsuffix`

**Schritte**:
1. `expand_brace()` rekursiv machen für verschachtelte Braces
2. Prefix/Suffix-Erkennung vor/nach Braces
3. Mehrfache Expansionen pro Token unterstützen

---

### 4. Tilde-Expansion erweitern
**Status**: Teilweise implementiert (`~`, `~user`)  
**Dateien**: `ziron-shell/src/parser.rs`

**Fehlende Features**:
- `~+` → Current directory (PWD)
- `~-` → Previous directory (OLDPWD)

**Schritte**:
1. `~+` und `~-` in Tilde-Expansion-Logik hinzufügen
2. PWD/OLDPWD aus Environment oder Shell-State lesen

---

## Priorität 2: Redirection & Here-Documents

### 5. File Descriptor Redirection
**Status**: Nicht implementiert  
**Dateien**: `ziron-shell/src/command.rs`, `ziron-shell/src/parser.rs`, `ziron-shell/src/executor.rs`

**Features**:
- `n>` für stdout redirection (z.B. `3>file`)
- `n<` für stdin redirection
- `n>&m` für file descriptor duplication

**Schritte**:
1. `Redirection` enum erweitern für File-Descriptor-Redirection
2. Parser erweitern für `n>`, `n<`, `n>&m` Syntax
3. Executor erweitern für File-Descriptor-Handling

---

### 6. Here-Document erweitern
**Status**: Basis-Implementierung vorhanden  
**Dateien**: `ziron-shell/src/parser.rs`, `ziron-shell/src/executor.rs`

**Fehlende Features**:
- Quoted delimiter (no expansion): `<<'EOF'` → keine Variable-Expansion
- Dash (`<<-`): Leading tabs entfernen

**Schritte**:
1. Parser erweitern für `<<'delimiter'` und `<<-delimiter`
2. Executor erweitern für Expansion-Control
3. Tab-Stripping für `<<-` implementieren

---

## Priorität 3: Tab Completion erweitern

### 7. Function Name Completion
**Status**: Nicht implementiert  
**Dateien**: `ziron-shell/src/completion.rs`, `ziron-shell/src/shell.rs`

**Schritte**:
1. Function-Storage in `ZironShell` hinzufügen
2. Function-Completion in `ZironCompleter` hinzufügen
3. Function-Definition-Syntax implementieren (z.B. `function name() { ... }`)

---

### 8. Custom Completion Functions
**Status**: Nicht implementiert  
**Dateien**: `ziron-shell/src/completion.rs`, `ziron-shell/src/shell.rs`

**Features**:
- Completion-Function-Registration
- Context-aware completion
- Argument-specific completion
- Completion-Function-API

**Schritte**:
1. Completion-Function-Trait definieren
2. Registration-System implementieren
3. Context-Informationen an Completion-Functions übergeben
4. Built-in Completion-Functions für häufige Commands

---

### 9. Completion UI erweitern
**Status**: Basis-Implementierung vorhanden  
**Dateien**: `ziron-shell/src/completion.rs`

**Fehlende Features**:
- Multi-column completion display
- Completion menu navigation
- Partial completion acceptance

**Schritte**:
1. `rustyline` Configuration für Multi-Column erweitern
2. Menu-Navigation implementieren
3. Partial-Completion-Logik hinzufügen

---

### 10. Case-Insensitive Completion
**Status**: Nicht implementiert  
**Dateien**: `ziron-shell/src/completion.rs`

**Schritte**:
1. Case-insensitive Option in `ZironCompleter` hinzufügen
2. Completion-Logik für Case-Insensitivity erweitern
3. Config-Option hinzufügen

---

## Priorität 4: Theming & UI

### 11. Multi-line Prompts
**Status**: Nicht implementiert  
**Dateien**: `ziron-core/src/prompt.rs`, `ziron-core/src/theme.rs`

**Schritte**:
1. Theme-Format erweitern für Multi-Line-Support
2. Prompt-Rendering für mehrere Zeilen anpassen
3. Line-Breaks in Theme-Konfiguration unterstützen

---

### 12. Right-side Prompt
**Status**: Nicht implementiert  
**Dateien**: `ziron-core/src/prompt.rs`, `ziron-core/src/theme.rs`

**Schritte**:
1. `right_prompt` in Theme-Struktur hinzufügen
2. Right-Prompt-Rendering implementieren
3. Terminal-Breite berücksichtigen für Positionierung

---

### 13. Prompt Timing Information
**Status**: Nicht implementiert  
**Dateien**: `ziron-core/src/prompt.rs`, `modules/timer/src/lib.rs`

**Schritte**:
1. Command-Start-Zeit in Shell-State speichern
2. Timer-Modul erweitern für Prompt-Integration
3. Formatierung für Timing-Informationen

---

### 14. Custom Color Palettes & Presets
**Status**: Nicht implementiert  
**Dateien**: `ziron-core/src/theme.rs`, `ziron-core/src/prompt.rs`

**Schritte**:
1. Color-Palette-System definieren
2. Preset-System implementieren
3. Theme-Konfiguration erweitern

---

## Priorität 5: Testing & Documentation

### 15. Testing Infrastructure
**Status**: Nicht implementiert  
**Dateien**: Neue Test-Dateien in `ziron-shell/src/`

**Features**:
- Unit tests für Parsing-Komponenten
- Integration tests für Built-in-Commands
- Completion-System-Tests
- Redirection-Tests
- Test-Coverage-Reporting

**Schritte**:
1. Test-Framework einrichten
2. Unit-Tests für Parser schreiben
3. Integration-Tests für Built-ins schreiben
4. Completion-Tests schreiben
5. Coverage-Tool konfigurieren

---

### 16. Documentation
**Status**: Teilweise vorhanden  
**Dateien**: `docs/` Verzeichnis

**Fehlende Dokumentation**:
- Built-in command documentation
- Parsing syntax documentation
- Completion system documentation
- Migration guide

**Schritte**:
1. Built-in-Command-Dokumentation schreiben
2. Parsing-Syntax-Dokumentation erstellen
3. Completion-System-Dokumentation schreiben
4. Migration-Guide erstellen

---

## Priorität 6: Performance & Optimierung

### 17. Performance Improvements
**Status**: Nicht implementiert

**Bereiche**:
- Parsing-Performance optimieren
- Completion-Lookup optimieren
- Memory-Usage reduzieren
- Startup-Zeit verbessern

**Schritte**:
1. Profiling durchführen
2. Bottlenecks identifizieren
3. Optimierungen implementieren
4. Benchmarks erstellen

---

## Implementierungsreihenfolge (Empfohlen)

### Phase 1: Script-Argumente & Arithmetic (Kritisch)
1. Script-Argumente (`$1`, `$2`, etc.)
2. Erweiterte Arithmetic-Expansion (Bitwise, Comparison)

### Phase 2: Parsing-Verbesserungen
3. Erweiterte Brace-Expansion (Nested, Prefix/Suffix)
4. Tilde-Expansion erweitern (`~+`, `~-`)

### Phase 3: Redirection
5. File Descriptor Redirection
6. Here-Document erweitern

### Phase 4: Completion erweitern
7. Function Name Completion
8. Custom Completion Functions
9. Completion UI erweitern
10. Case-Insensitive Completion

### Phase 5: Theming
11. Multi-line Prompts
12. Right-side Prompt
13. Prompt Timing Information
14. Custom Color Palettes

### Phase 6: Testing & Docs
15. Testing Infrastructure
16. Documentation

### Phase 7: Performance
17. Performance Improvements

---

## Geschätzter Aufwand

- **Phase 1**: 2-3 Tage
- **Phase 2**: 1-2 Tage
- **Phase 3**: 1-2 Tage
- **Phase 4**: 3-4 Tage
- **Phase 5**: 2-3 Tage
- **Phase 6**: 2-3 Tage
- **Phase 7**: 2-3 Tage

**Gesamt**: ~13-20 Tage

---

## Notizen

- Alle Features sollten ohne `#[allow(dead_code)]` implementiert werden
- Nach jeder Implementierung: `cargo build --release` testen
- Features in `docs/v0.2.0.md` abhaken nach Implementierung
- Tests schreiben für kritische Features
- Dokumentation parallel zur Implementierung aktualisieren

